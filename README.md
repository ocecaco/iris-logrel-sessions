# iris-logrel-sessions
This repository contains a Coq formalization of a logical relations proof of type safety for a programming language with session types, using the Iris concurrent separation logic. The programming language, HeapLang, is an untyped ML-like language with support for message-passing concurrency based on channels between threads. It also supports shared-memory concurrency using heap references and atomic instructions.

Type safety is a property of programming language type systems, which ensures that programs which pass the type checker do not crash unexpectedly at runtime. However, type systems are often too restrictive, rejecting programs which are in fact perfectly safe. To give a simple example, the program `if true then 0 else 5 + "hello"` would be rejected by most type checkers, since it attempts to add a string and an integer in the false branch of the if expression. But intuitively this program is of type `int`, since it will always evaluate to an integer. We know it is safe to treat this as a program of type `int`, but we cannot convince the type checker of this fact.

Languages like Rust provide you with an escape hatch for when you _know_ that a certain piece of code is type-safe, but the type checker cannot see this. It allows you to put code in `unsafe` blocks, where the type checker considerably relaxes it checks and allows you to perform dangerous operations, such as reads and writes from arbitrary memory locations, which might endanger the guarantees ordinarily provided by the type system. In this case, the responsibility of making sure the unsafe code is type-safe lies with the programmer.

Logical relations proofs of type safety allow you to formally prove that code in unsafe blocks is still safe. Such proofs work by defining when a program has a certain type in terms of its _behavior_, instead of its syntactic structure. For example, an expression is defined to be of type `int` if it always evaluates to an integer. This leads to a less restrictive notion of type safety than that employed by type checkers. It allows you to have most parts of your program type checked by the type checker, with the exception of some parts, which can be manually verified by reasoning about program behavior.
